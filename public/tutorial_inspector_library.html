<!DOCTYPE html><html><head><meta http-equiv="Content-Type" content="text/html;charset=utf-8"><title>Tutorial: Inspector Library</title><link rel="stylesheet" href="vendor/stylesheets/bootstrap.min.css"><link rel="stylesheet" href="stylesheets/layout.css"><link rel="stylesheet" href="stylesheets/layout_components.css"><script type="application/javascript" src="vendor/javascripts/jquery-1.7.2.js"></script><link rel="stylesheet" href="stylesheets/tutorial.css"><script type="application/javascript" src="vendor/javascripts/knockout-2.1.0.debug.js"></script><script type="application/javascript" src="vendor/javascripts/underscore-1.3.1.js"></script><script type="application/javascript" src="vendor/javascripts/backbone-0.9.2.js"></script><script type="application/javascript" src="vendor/javascripts/knockback-0.15.1.js"></script><link rel="stylesheet" href="vendor/lib/highlight/highlightjs/stylesheets/dark.css"><script type="application/javascript" src="vendor/lib/highlight/highlightjs/highlight.js"></script><script type="application/javascript" src="vendor/lib/highlight/highlightjs/languages/javascript.js"></script><script type="application/javascript" src="vendor/lib/highlight/highlight-coffee.js"></script><script type="application/javascript" src="vendor/javascripts/bootstrap.js"></script><script type="application/javascript" src="javascripts/interface.js"></script><script type="application/javascript">hljs.tabReplace = '  ';
hljs.initHighlightingOnLoad();</script></head><body><div id="wrap"><div class="page navbar"><div class="navbar page"><div class="navbar-inner"><div class="container"><a class="brand kb">Knockback.js</a><ul class="nav"><li><a href="index.html">Home</a></li><li><a href="tutorial_getting_started.html">Getting Started</a></li><li><a href="docs.html">Docs</a></li><li class="dropdown"><a href="#" data-toggle="dropdown" class="dropdown-toggle">Tutorials<b class="caret"></b></a><ul class="dropdown-menu"><li></li><a href="tutorial_getting_started.html">Getting Started</a><a href="tutorial_kb_view_model.html">kb.ViewModel</a><a href="tutorial_kb_observable_options.html">kb.Observable Options</a><a href="tutorial_kb_localized_observable.html">kb.LocalizedObservable</a><a href="tutorial_relational_models.html">Relational Models</a><a href="tutorial_locale_manager.html">Custom Locale Manager</a><a href="tutorial_todos_app.html">Todos App</a><a href="tutorial_inspector_library.html">Inspector Library</a></ul></li><li><a href="release_notes.html">Release Notes</a></li></ul><div id="script_language"><div class="separator"><div class="selection codestyle"><div class="option"><input id="cs-cs" type="radio" name="codestyle" value="cs" class="auto"/><label for="cs-cs">CoffeeScript</label></div><div class="option"><input id="cs-js" type="radio" name="codestyle" value="js"/><label for="cs-js">Javascript</label></div></div></div></div></div></div></div></div></div><div id="wrap"><div class="page container"><header class="page"></header><content class="page"><section><h1>Tutorial: Knockback Inspector Library</h1><p>This tutorial shows how to create an inspector for a Backbone.Model or a Backbone.Collection that you can embed in your website for debugging purposes. For a model, the inspector allows you to view and edit its attributes including nested models and collections; for a collection, the inspector allows you to view and edit its models.</p><p><span>Although the inspector can be useful as presented in this tutorial, this version is simple and stripped down for learning purposes; for example, it does not treat changing of model ids as a special case, there are no special editors for time/date/color attribute types, etc. For the latest full implementation:</span><ul><li><a href="https://github.com/kmalakoff/knockback-inspector/">View the GitHub project</a></li><li><a href="http://kmalakoff.github.com/knockback-inspector/">Try the demo</a></li></ul><span>Feel free to contribute to the GitHub project with your own ideas or with some of the proposals in the &quot;Future Enhancements&quot; section.</span></p><h2>Table of Contents</h2><ol><li><a href="#overview">Overview</a></li><li><a href="#html_templates">HTML Templates</a></li><li><a href="#control_flow_architecture">Control Flow</a></li><li><a href="#library_architecture">Library Architecture</a></li></ol><h2 id="overview">Overview</h2><p>Let's start with the goals of a simple model and collection inspector...</p><h4>Model Inspector Goals</h4><ul><li>For each simple-typed attribute, provide a label for the attribute name and a text box to edit the value</li><li>For each model-typed attribute, provide a collapsable node with the attribute name and when opened, allow each model attribute to be inspected by type</li><li>For each collection-typed attribute, provide a collapsable node with the attribute name and when opened, allow each model to be inspected</li></ul><h4>Collection Inspector Goals</h4><ul><li>For each model-typed attribute, provide a collapsable node with the index model and when opened, allow each model attribute to be inspected bytype</li></ul><h3>Inspector Visualization</h3><p>Here is what the inspector could look like for a house model that has a location (simple-typed attribute) and multiple occupants (collection-typed attribute) who each has an id (simple-typed attribute), a name (simple-typed attribute), and who know which house they are living in (model-typed attribute):</p><br><img src="images/tutorial_inspector/screen_shot.png" class="screen_shot"><br><h3 id="html_templates">HTML Templates</h3><p>Given the recursiveness of the design, I chose to implement this functionality using two reusable HTML templates: one for a model node that generates HTML for each of its attributes and one for a collection node that generates HTML for each for its models:</p><h4>Model Node View Structure (template: 'kbi_model_node')</h4><p>Here is some pseudo-HTML for the model node:</p><pre>&lt;li data-bind=&quot;css: {opened: opened, closed: !opened()}&quot;&gt;
  &lt;div data-bind=&quot;click: toggle&quot;&gt;
    &lt;span data-bind=&quot;text: (opened() ? '- ' : '+ ' )&quot;&gt;&lt;/span&gt;
    &lt;span data-bind=&quot;text: name&quot;&gt;&lt;/span&gt;
  &lt;/div&gt;
  
  &lt;form&gt;
    &lt;!-- FOREACH ATTRIBUTE --&gt;
    
      &lt;!-- IF SIMPLE --&gt;
        &lt;fieldset&gt;
          &lt;label&gt;&lt;/label&gt;
          &lt;input type=&quot;text&quot;&gt;
        &lt;/fieldset&gt;
        
      &lt;!-- ELSE IF MODEL --&gt;
        &lt;!-- RENDER MODEL NODE --&gt;
        
      &lt;!-- ELSE IF COLLECTION --&gt;
        &lt;!-- RENDER COLLECTION NODE --&gt;
        
  &lt;/form&gt;
&lt;/li&gt;</pre><strong>Highlights:</strong><ul><li>Each model node uses a &lt;li&gt; that can either be in opened or closed state</li><li>Use a &lt;div&gt; to wrap a +/- state indicator, the name of the node, and a click handler to toggle the opened/closed state of the node</li><li>The model attributes are grouped in a &lt;form&gt;</li><li>Each simple-typed attribute are wrapped in a &lt;fieldset&gt; in with a &lt;label&gt; and &lt;input&gt; for the name and value, respectively</li><li>Each model-typed attribute are rendered using the model node template</li><li>Each collection-typed attribute are rendered using the collection node template</li></ul><h4>Collection Node View Structure (template: 'kbi_collection_node')</h4><p>Here is some pseudo-HTML for the collection node:</p><pre>&lt;li data-bind=&quot;css: {opened: opened, closed: !opened()}&quot;&gt;
  &lt;div data-bind=&quot;click: toggle&quot;&gt;
    &lt;span data-bind=&quot;text: (opened() ? '- ' : '+ ' )&quot;&gt;&lt;/span&gt;
    &lt;span data-bind=&quot;text: name&quot;&gt;&lt;/span&gt;
  &lt;/div&gt;
  
  &lt;!-- FOREACH MODEL --&gt;
    &lt;!-- RENDER MODEL NODE --&gt;
&lt;/li&gt;
</pre><strong>Highlights:</strong><ul><li>Each collection node uses a &lt;li&gt; that can either be in opened or closed state</li><li>Use a &lt;div&gt; to wrap a +/- state indicator, the name of the node, and a click handler to toggle the opened/closed state of the node</li><li>The collection's models are wrapped in an &lt;ul&gt; and each model can be rendered using the model node template</li></ul><h2 id="control_flow">Control Flow</h2><p><span>We can implement an inspector by:</span><ol><li>Using Knockback to generate a graph starting at a kb.ViewModel or kb.CollectionObservable from a Backbone.Model or Backbone.Collection, respectively.</li><li>Using Knockout to traverse the graph, to wrap each kb.ViewModel node or kb.CollectionObservable node in a NodeViewModel, and to conditionally continue to render the graph depending on the opened/closed state of the node.</li></ol></p><h3>Graph Generation</h3><P><span>By default, a </span><a href="docs_kb_view_model.html">kb.ViewModel</a><span> will generate a kb.ViewModel for each of its nested models and a kb.collectionObservable for each of its nested collections when used like:</span><pre>kb.viewModel(my_model)</pre></P><P><span>Also, a </span><a href="docs_kb_collection_observable.html">kb.CollectionObservable</a><span> can easily be configured to generate a kb.ViewModel for each of its models when configured like: </span><pre>kb.collectionObservable(my_collection, {view_model: kb.ViewModel})</pre></P><P>What this means is that Knockback takes care of circular references between Backbone.Models or Backbone.Collections so you don't have to. In the case of circular references, you just need to be careful to handle cycles correctly when you traverse the nodes in the graph.</P><h3>Traversing the Graph</h3><p>Because there can be cycles between the models and collections in the graph, the inspector uses a separate kbi.NodeViewModel to expose properties for the opened/closed state of the node, the name of the node, and the (potentially shared) node itself. A kbi.NodeViewModel is constructed with the following parameters: (name, opened_state, kb.ViewModel or kb.CollectionObservable).</p><p>By doing this, the same kb.ViewModel for a model can be opened or closed in different parts of the tree and can have unique names depending on where it is referenced from.</p><p>Also, each of the node templates, needs to take appropriate action to block the full tree from being rendered out when a kbi.NodeViewModel is in the closed state. With Knockout, this is easy to do using a '&lt;!-- ko if: opened --&gt;' control flow statement.</p><p>Updating the 'kbi_model_node' pseudo HTML: </p><pre>&lt;li data-bind=&quot;css: {opened: opened, closed: !opened()}&quot;&gt;
  &lt;div data-bind=&quot;click: toggle&quot;&gt;
    &lt;span data-bind=&quot;text: (opened() ? '- ' : '+ ' )&quot;&gt;&lt;/span&gt;
    &lt;span data-bind=&quot;text: name&quot;&gt;&lt;/span&gt;
  &lt;/div&gt;
  
  &lt;!-- ko if: opened --&gt;
    &lt;form&gt;
      &lt;!-- FOREACH ATTRIBUTE --&gt;
      
        &lt;!-- IF SIMPLE --&gt;
          &lt;fieldset&gt;
            &lt;label&gt;&lt;/label&gt;
            &lt;input type=&quot;text&quot;&gt;
          &lt;/fieldset&gt;
          
        &lt;!-- ELSE IF MODEL --&gt;
          &lt;ul data-bind=&quot;template: {name: 'kbi_model_node', data: new kbi.NodeViewModel(attribute_name, false, node)}&quot;&gt;&lt;/ul&gt;
          
        &lt;!-- ELSE IF COLLECTION --&gt;
          &lt;ul data-bind=&quot;template: {name: 'kbi_collection_node', data: new kbi.NodeViewModel(attribute_name+'[]', true, node)}&quot;&gt;&lt;/ul&gt;
          
    &lt;/form&gt;
  &lt;!-- /ko --&gt;
&lt;/li&gt;
</pre><p>Updating the 'kbi_collection_node' pseudo HTML: </p><pre>&lt;li data-bind=&quot;css: {opened: opened, closed: !opened()}&quot;&gt;
  &lt;div data-bind=&quot;click: toggle&quot;&gt;
    &lt;span data-bind=&quot;text: (opened() ? '- ' : '+ ' )&quot;&gt;&lt;/span&gt;
    &lt;span data-bind=&quot;text: name&quot;&gt;&lt;/span&gt;
  &lt;/div&gt;
  
  &lt;!-- ko if: opened --&gt;
    &lt;!-- FOREACH MODEL --&gt;
      &lt;ul data-bind=&quot;template: {name: 'kbi_model_node', data: new kbi.NodeViewModel('['+$index()+']', false, node)}&quot;&gt;&lt;/ul&gt;
  &lt;!-- /ko --&gt;
&lt;/li&gt;
</pre><p><strong>Please note:</strong><ul><li>Each kb.ViewModel or kb.CollectionObservable node is rendered with &lt;ul&gt; to start a new tree that is filled in by either the 'kbi_model_node' or 'kbi_collection_node' templates.</li><li>Each kbi.NodeViewModel is given a name to indicate its relationship.</li><li>In the case of models, the templates are rendered in a closed state to break potential cycles; whereas, collections are rendered in an open state so we are presented with the indices of the contained models.</li><li>When the node is closed, only the HTML that displays the name of the node and allows for a click to open the node is generated.</li></ul></p><h2 id="library_architecture">Library Architecture</h2><p>Knockback-Inspector will be designed as a library meaning:<ol><li>The library will be in the 'kbi' namespace</li><li>The library version will be available in 'kbi.VERSION'</li><li><span>The library code will be separated into multiple directories and files as follows:</span><pre>- lib
  - kbi_core.js
  - kbi_string_template_engine.js
- models
  - kbi_fetched.js
- view_models
  - kbi_node_view_model.js
- views
  - kbi_collection_node_view.js
  - kbi_model_node_view.js
  </pre></li><li><span>The Library, Model, ViewModel, and View files contain the following implementations:</span><ul><li><strong>kbi_core.js: </strong><ul><li>provides the kbi namespace</li><li>provides the kbi.VERSION semantic versioning string</li></ul></li><li><strong>kbi_string_template_engine.js: </strong><ul><li>implements kbi.StringTemplateSource and kbi.StringTemplateEngine to expose the 'kbi_model_node' and 'kbi_collection_node' templates to Knockout.js</li></ul></li><li><strong>kbi_fetched.js: </strong><ul><li>implements the kbi.FetchedModel class to provide a Backbone.Model implementation with function that can be used to inspect a JSON server response when you do not have your own specialized implementation</li><li>implements the kbi.FetchedCollection class to provide a Backbone.Collection implementation with parse function that can be used to inspect a JSON server response when you do not have your own specialized implementation</li></ul></li><li><strong>kbi_node_view_model.js: </strong><ul><li>implements the kbi.NodeViewModel class to create a ViewModel instance for each kb.ViewModel or kb.CollectionObservable node in the graph with a name and opened state</li></ul></li><li><strong>kbi_collection_node_view.js: </strong><ul><li>provides kbi.CollectionNodeView which holds an HTML string that is used by the kbi.StringTemplateEngine whenever Knockout.js requests the 'kbi_collection_node' template</li></ul></li><li><strong>kbi_model_node_view.js: </strong><ul><li>provides kbi.ModelNodeView which holds an HTML string that is used by the kbi.StringTemplateEngine whenever Knockout.js requests the 'kbi_model_node' template</li></ul></li></ul></li></ol></p><p><li><span>Because the kbi.NodeViewModel class is shared for kb.ViewModel and kb.CollectionObservable nodes, in the case of kb.ViewModel, we need to add slightly more functionality to handle exposing and traversing the attributes:</span><ol><li><strong>Attribute Names</strong><span> : in order to be able to iterate through all of the attributes in a Backbone.Model with Knockout, we will store their names in an array.</span></li><li><strong>Attribute Types</strong><span> : in order to select the correct attribute rendering in the template, we provide a helper function called 'attributeType()' that returns the string 'simple', 'model', or 'collection'</span></li></ol><p>Updating the pseudo-HTML for the model node:</p><pre>&lt;li data-bind=&quot;css: {opened: opened, closed: !opened()}&quot;&gt;
  &lt;div data-bind=&quot;click: toggle&quot;&gt;
    &lt;span data-bind=&quot;text: (opened() ? '- ' : '+ ' )&quot;&gt;&lt;/span&gt;
    &lt;span data-bind=&quot;text: name&quot;&gt;&lt;/span&gt;
  &lt;/div&gt;
  
  &lt;!-- ko if: opened --&gt;
    &lt;form&gt;
      &lt;!-- ko foreach: attribute_names --&gt;
      
        &lt;!-- ko if: ($parent.attributeType($data) == 'simple') --&gt;
          &lt;fieldset&gt;
            &lt;label class='control-label' data-bind=&quot;text: $data&quot;&gt; &lt;/label&gt;
            &lt;input type=&quot;text&quot; data-bind=&quot;value: $parent.node[$data]&quot;&gt;
          &lt;/fieldset&gt;
        &lt;!-- /ko --&gt;
        
        &lt;!-- ko if: ($parent.attributeType($data) == 'model') --&gt;
          &lt;ul data-bind=&quot;template: {name: 'kbi_model_node', data: new kbi.NodeViewModel($data, false, $parent.node[$data])}&quot;&gt;&lt;/ul&gt;
        &lt;!-- /ko --&gt;
        
        &lt;!-- ko if: ($parent.attributeType($data) == 'collection') --&gt;
          &lt;ul data-bind=&quot;template: {name: 'kbi_collection_node', data: new kbi.NodeViewModel($data+'[]', true, $parent.node[$data])}&quot;&gt;&lt;/ul&gt;
        &lt;!-- /ko --&gt;
        
      &lt;!-- /ko --&gt;
    &lt;/form&gt;
  &lt;!-- /ko --&gt;
  
&lt;/li&gt;</pre><p><strong>Please note:</strong><span> because Knockout.js pushes a new binding context on the stack during the iteration through the attribute_names, $data is mapped to the attribute name and the attribute itself can be accessed in the parent context using $parent.node[$data])</span></p></li><p>OK. Let's start...</p></p><h2>Step 1: Setting up the Project</h2><p>This tutorial demonstrates how to use Knockback to create a tree view to inspect Backbone.Model attributes and Backbone.Collections including potentially recursive relationships between models.</p><p>The application is built using CoffeeScript and JavaScript.</p><h3>Shared</h3><ol><li><span>Create a new project with the following structure: </span><pre>- knockback-inspector
  - vendor
    - javascripts</pre></li><li><span>Put all of the dependent libraries into the 'vendor/javascripts' folder</span><ul><li><a href="http://jquery.com/">jQuery.js</a></li><li><a href="https://github.com/SteveSanderson/knockout/downloads/">Knockout.js</a></li><li><a href="http://documentcloud.github.com/underscore/">Underscore.js</a></li><li><a href="http://documentcloud.github.com/backbone/">Backbone.js</a></li><li><a href="http://kmalakoff.github.com/knockback/">Knockback.js</a></li><li><a href="https://github.com/PaulUithol/Backbone-relational/">Backbone-Relational (optional, but recommended)</a></li></ul></li><li><span>Create an index.html file in the root project directory referring to all the dependencies like (updating version and production/development version naming to match your files):</span><pre>- knockback-inspector
  - index.html
  - vendor
    - javascripts</pre><pre>&lt;!doctype html&gt;
&lt;head&gt;
  &lt;meta charset=&quot;utf-8&quot;&gt;
  &lt;meta http-equiv=&quot;X-UA-Compatible&quot; content=&quot;IE=edge,chrome=1&quot;&gt;
  &lt;title&gt;Knockback Inspector&lt;/title&gt;
  &lt;script src=&quot;vendor/javascripts/jquery-1.7.2.js&quot;&gt;&lt;/script&gt;
  &lt;script src=&quot;vendor/javascripts/knockout-2.1.0.js&quot;&gt;&lt;/script&gt;
  &lt;script src=&quot;vendor/javascripts/underscore-1.3.1.js&quot;&gt;&lt;/script&gt;
  &lt;script src=&quot;vendor/javascripts/backbone-0.9.2.js&quot;&gt;&lt;/script&gt;
  &lt;script src=&quot;vendor/javascripts/backbone-relational.js&quot;&gt;&lt;/script&gt;
  &lt;script src=&quot;vendor/javascripts/knockback-0.15.1.js&quot;&gt;&lt;/script&gt;
&lt;/head&gt;
&lt;body&gt;
  &lt;h1&gt;Knockback Inspector&lt;/h1&gt;
&lt;/body&gt;
&lt;/html&gt;</pre></li><li><span>Now open your index.html. You should see 'Knockback Inspector' in the page and there should be no missing file errors in your browser's debugger.</span></li></ol><h3>JavaScript</h3><ol><li><span>Create a new project with the following structure: </span><pre>- knockback-inspector
  - index.html
  - javascripts
  - vendor
    - javascripts</pre></li></ol><h3>Building a Scaffold Project (CoffeeScript)</h3><ol><li><span>Create a new project with the following structure: </span><pre>- knockback-inspector
  - index.html
  - coffeescripts
  - vendor
    - javascripts</pre></li><li><span>Install </span><a href="http://nodejs.org/">Node.js</a></li><li><span>Install </span><a href="http://coffeescript.org/">CoffeeScript</a><pre>(sudo) npm install -g coffee-script
</pre></li><li><span>If you are using CoffeeScript, you need to set up an executable Cakefile build file with 'build' and 'watch' commands like:</span><pre>{print} = require 'util'
{spawn} = require 'child_process'

task 'build', 'Build javascripts/ from coffeescripts/', -&gt;
  coffee = spawn 'coffee', ['-c', '-o', 'javascripts', 'coffeescripts']
  coffee.stderr.on 'data', (data) -&gt;
    process.stderr.write data.toString()
  coffee.stdout.on 'data', (data) -&gt;
    print data.toString()
  coffee.on 'exit', (code) -&gt;
    callback?() if code is 0
    
task 'watch', 'Watch coffeescripts/ for changes', -&gt;
  coffee = spawn 'coffee', ['-w', '-c', '-o', 'javascripts', 'coffeescripts']
  coffee.stderr.on 'data', (data) -&gt;
    process.stderr.write data.toString()
  coffee.stdout.on 'data', (data) -&gt;
    print data.toString()
    </pre></li></ol><h2>Step 2: Create a Hard-Coded Version Embedded in index.html</h2><p><span>First, we will hard-code a model and collection relationship in index.html. We will use straight JavaScript in this step since it will be included in the .html file body as:</span><pre>&lt;script type='text/javascript'&gt;
  var collection = new Backbone.Collection([]);
  var model1 = new Backbone.Model({name: 'Model1', friends: collection});
  var model2 = new Backbone.Model({name: 'Model2', friend: model1});
  collection.add(model2);
&lt;/script&gt;</pre></p><p><span>TODO:</span><pre data-for="cs">@kbi or= {}
@kbi.VERSION = '0.1.0'</pre><pre data-for="js">TODO
</pre><span>Next, we will create the ViewModel nodes for the kb.ViewModel and kb.CollectionObservable. To keep things simple, we'll create a single ViewModel class for both collections and models starting with 'view_models/kbi_node_view_model.coffee' or 'view_models/kbi_node_view_model.js':</span><pre data-for="cs">class kbi.NodeViewModel
  constructor: (name, opened, kb_object) -&gt;
    @name = name
    @opened = ko.observable(opened)
    @kb_object = kb_object
    
  toggle: -&gt; @opened(!@opened())</pre><pre data-for="js">TODO
</pre><span>Next, we will add the attribute functionality used for Backbone.Model's kb.ViewModels:</span><pre data-for="cs">class kbi.NodeViewModel
  constructor: (name, opened, kb_object) -&gt;
    @name = name
    @opened = ko.observable(opened)
    @kb_object = kb_object
    
    # a kb.ViewModel indicates the kb_object is a Backbone.Model
    if (@kb_object instanceof kb.ViewModel)
      model = kb.utils.wrappedModel(@kb_object)
      @attributes = ko.observableArray(if (model and model.attributes) then _.keys(model.attributes) else [])
      
  toggle: -&gt; @opened(!@opened())
  
  attributeType: (key) -&gt;
    attribute_connector = @kb_object[key]
    return 'model' if (ko.utils.unwrapObservable(attribute_connector) instanceof kb.ViewModel)
    return 'collection' if kb.utils.observableInstanceOf(attribute_connector, kb.CollectionAttributeConnector)
    return 'simple'</pre><pre data-for="js">TODO
</pre><p><span>The new code in the constructor checks to see if the Knockback object is a kb.ViewModel meaning it wraps a Backbone.Model and if so, it stores the attribute names in a ko.observableArray for later traversing</span><pre data-for="cs"># a kb.ViewModel indicates the kb_object is a Backbone.Model
if (@kb_object instanceof kb.ViewModel)
  model = kb.utils.wrappedModel(@kb_object)
  @attributes = ko.observableArray(if (model and model.attributes) then _.keys(model.attributes) else [])</pre><pre data-for="js">TODO
</pre></p><p><span>The new function 'attributeType(key)' is a helper to see what type each attribute is so that Views for nested models, collections, and simple attribute types can be selected more easily.</span><pre data-for="cs">attribute_connector = @kb_object[key]
return 'model' if (ko.utils.unwrapObservable(attribute_connector) instanceof kb.ViewModel)
return 'collection' if kb.utils.observableInstanceOf(attribute_connector, kb.CollectionAttributeConnector)
return 'simple'</pre><pre data-for="js">TODO
</pre></p><span>Next, we will create the View templates for each node type. Because Knockout handles all of the dynamic aspects of the template, we can simply use a static string for our templates</span></p><h3>Views<p><span>TODO: add styles including kbi classes</span></p><p><span>Let's start with the kb.CollectionObservable View by creating the following file in 'views/kbi_collection_node_view_html.coffee' or 'views/kbi_collection_node_view_html.js'</span></p><pre data-for="cs">kbi.CollectionNodeViewHTML = &quot;&quot;&quot;
&lt;li&gt;
  &lt;span&gt;&lt;i data-bind=&quot;click: toggle, css:{'icon-plus': !opened(), 'icon-minus': opened}&quot;&gt;&lt;/i&gt;&lt;/i&gt;&lt;i class=&quot;icon-th-list&quot;&gt;&lt;/i&gt; &lt;span data-bind=&quot;text: name&quot;&gt;&lt;/span&gt;&lt;/span&gt;
  
  &lt;!-- ko if: opened --&gt;
    &lt;div data-bind=&quot;foreach: collection_observable&quot;&gt;
      &lt;ul class='tree' data-bind=&quot;template: {name: 'views/templates/model_node', data:  collectionModelNodeViewModel($parent.collection_observable, false, $data)}&quot;&gt;&lt;/ul&gt;
    &lt;/div&gt;
  &lt;!-- /ko --&gt;
&lt;/li&gt;
&quot;&quot;&quot;</pre><pre data-for="js">TODO
</pre><span>For the kb.ViewModel View we will create the following file in 'views/kbi_model_node_view_html.coffee' or 'views/kbi_model_node_view_html.js'. To start with, let's look at the high level structure:</span><pre data-for="cs">kbi.ModelNodeViewHTML = &quot;&quot;&quot;
&lt;li&gt;
  &lt;span&gt;&lt;i data-bind=&quot;click: toggle, css:{'icon-plus': !opened(), 'icon-minus': opened}&quot;&gt;&lt;/i&gt;&lt;/i&gt;&lt;i class=&quot;icon-book&quot;&gt;&lt;/i&gt; &lt;span data-bind=&quot;text: name&quot;&gt;&lt;/span&gt;&lt;/span&gt;
  &lt;!-- ko if: opened --&gt;
    &lt;!-- ko foreach: attributes --&gt;
    
      &lt;!-- ko if: ($parent.attributeType($data) == 'model') --&gt;
        ...
      &lt;!-- /ko --&gt;
      
      &lt;!-- ko if: ($parent.attributeType($data) == 'collection') --&gt;
        ...
      &lt;!-- /ko --&gt;
      
      &lt;!-- ko if: ($parent.attributeType($data) == 'simple') --&gt;
        ...
      &lt;!-- /ko --&gt;
      
    &lt;!-- /ko --&gt;
  &lt;!-- /ko --&gt;
&lt;/li&gt;
&quot;&quot;&quot;</pre><pre data-for="js">TODO
</pre><p><span>The structure is similar to View for a collection node. We only render the attributes if the node is opened, and when opened, we traverse each attribute and depending on each type (model, collection, or simple), we render them. OK. Let's add the rendering per type.</span></p><h4>Model Attributes</h4><p><span>For a model, we just rendering the same template again as follows:</span><pre>&lt;ul class='kbi' data-bind=&quot;template: {name: 'kbi_model_node', data: new kbi.NodeViewModel($data, false, $parent.kb_object[$data])}&quot;&gt;&lt;/ul&gt;
</pre><span>Note: because we are rendering the template inside the iteration of attributes, $data stores the attribute name and the attribute information is in the parent's kb.ViewModel so we access it using Knockout's $parent in the binding context like '$parent.kb_object[$data]'.</span></p><h4>Collection Attributes</h4><p><span>For a collection, we render the collection node template and generate a name using the $index property that Knockout provides:</span><pre>&lt;ul class='kbi' data-bind=&quot;template: {name: 'kbi_collection_node', data: new kbi.NodeViewModel($data, true, $parent.kb_object[$data])}&quot;&gt;&lt;/ul&gt;
</pre><span>Note: because we are rendering the template inside the iteration of attributes, $data stores the attribute name and the attribute information is in the parent's kb.ViewModel so we access it using Knockout's $parent in the binding context like '$parent.kb_object[$data]'.</span></p><h4>Simple Attributes</h4><p><span>For the attributes, we will just create a label and text input box.</span><pre>&lt;fieldset&gt;
  &lt;label class='control-label' data-bind=&quot;text: $data&quot;&gt; &lt;/label&gt;
  &lt;input class='input-large' type=&quot;text&quot; data-bind=&quot;value: $parent.kb_object[$data]&quot;&gt;
&lt;/fieldset&gt;
</pre></p><h4>Putting it all together</h4><p><span>If we combine everything, we get the following template.</span><pre>kbi.ModelNodeViewHTML = &quot;&quot;&quot;
&lt;li class='kbi'&gt;
  &lt;div class='kbi model' data-bind=&quot;click: toggle, css: {opened: opened, closed: !opened()}&quot;&gt;&lt;span data-bind=&quot;text: name&quot;&gt;&lt;/span&gt; (M)&lt;/div&gt;
  
  &lt;!-- ko if: opened --&gt;
    &lt;form class='kbi'&gt;
      &lt;!-- ko foreach: attributes --&gt;
      
        &lt;!-- ko if: ($parent.attributeType($data) == 'model') --&gt;
          &lt;ul class='kbi' data-bind=&quot;template: {name: 'kbi_model_node', data: new kbi.NodeViewModel($data, false, $parent.kb_object[$data])}&quot;&gt;&lt;/ul&gt;
        &lt;!-- /ko --&gt;
        
        &lt;!-- ko if: ($parent.attributeType($data) == 'collection') --&gt;
          &lt;ul class='kbi' data-bind=&quot;template: {name: 'kbi_collection_node', data: new kbi.NodeViewModel($data, true, $parent.kb_object[$data])}&quot;&gt;&lt;/ul&gt;
        &lt;!-- /ko --&gt;
        
        &lt;!-- ko if: ($parent.attributeType($data) == 'simple') --&gt;
          &lt;fieldset&gt;
            &lt;label class='control-label' data-bind=&quot;text: $data&quot;&gt; &lt;/label&gt;
            &lt;input class='input-large' type=&quot;text&quot; data-bind=&quot;value: $parent.kb_object[$data]&quot;&gt;
          &lt;/fieldset&gt;
        &lt;!-- /ko --&gt;
        
      &lt;!-- /ko --&gt;
    &lt;/form&gt;
  &lt;!-- /ko --&gt;
&lt;/li&gt;
&quot;&quot;&quot;
</pre></p><h3>Exposing the Templates to Knockout</h3><p><span>Knockout works out of the box on a static HTML page where all templates are inlined, but because we are providing our templates in a library as strings and because they can be recursive, we have assigned them names 'kbi_collection_node' and 'kbi_model_node' that need to be looked up somewhere to provide the HTML to Knockout for binding purposes. There are two implementations Knockout requires for this: 'templateEngine' and 'templateSource': you can look at </span><a href="http://www.knockmeout.net/2011/10/ko-13-preview-part-3-template-sources.html">an in-depth tutorial online for a full implementation</a><span>but for now, I'll try to keep the code and support to a minimum</span></p><pre data-for="cs">TODO</pre><pre data-for="js">// template source
kbi.StringTemplateSource = function(template_string) {
  this.template_string = template_string;
  return this;
};
kbi.StringTemplateSource.prototype.text = function(value) { return this.template_string; };

// template engine
kbi.StringTemplateEngine = function() { return this; };
kbi.StringTemplateEngine.prototype = new ko.nativeTemplateEngine();
kbi.StringTemplateEngine.prototype.makeTemplateSource = function(template) {
  switch (template) {
    case 'kbi_model_node':
      return new kbi.StringTemplateSource(kbi.ModelNodeViewHTML);
    case 'kbi_collection_node':
      return new kbi.StringTemplateSource(kbi.CollectionNodeViewHTML);
    default:
      return ko.nativeTemplateEngine.prototype.makeTemplateSource.apply(this, arguments);
  }
};
</pre><p>The kbi.StringTemplateSource is a template source that uses a 'text' function to return an HTML string (but does not handle Knockout template re-writing nor data storage).</p><p>The kbi.StringTemplateEngine derives from ko.nativeTemplateEngine() and returns a kbi.StringTemplateSource is if recognizes the name or the default implementation otherwise. If you want to integrate the Knockout-Inspector templates into your own application, you'll need to supply a similar way to return the View strings.</p><p>We tell Knockout about our custom 'kbi.StringTemplateEngine' template engine using the following call in index.html:</p><pre>&lt;script type='text/javascript'&gt;
  // set the template engine so Knockout can find 'kbi_model_node' and 'kbi_collection_node' templates
  ko.setTemplateEngine(new kbi.StringTemplateEngine());
&lt;/script&gt;</pre><p>Setting the template engine is done in the index.html file rather than the library so you can hook up your own template engine implementation as you need depending on which template engine you are using.</p><h3>Hooking up index.html</h3><p>Next, we need to update the index file to provide all of the javascript files</p><pre>&lt;script src=&quot;javascripts/view_models/kbi_node_view_model.js&quot;&gt;&lt;/script&gt;
&lt;script src=&quot;javascripts/views/kbi_collection_node_view.js&quot;&gt;&lt;/script&gt;
&lt;script src=&quot;javascripts/views/kbi_model_node_view.js&quot;&gt;&lt;/script&gt;
&lt;script src=&quot;javascripts/lib/kbi_string_template_engine.js&quot;&gt;&lt;/script&gt;
</pre><h3>Providing Sample Data to Inspect</h3><p></p></h3><h2>Step 3: Add Model Fetching</h2><p>TODO</p><h2>Step 4: Create a Reusable Library Version</h2><p>TODO</p><h2>Future Enhancement Ideas</h2><p><span>The inspector works for the most part, but as with anything it can always be improved! Here are some ideas: </span><ul><li><strong>Customized Attribute Editing</strong><span>: currently, each attribute can be edited using a text box, but for some attribute types, this isn't very useful. Specific attribute editors could be rendered depending on the attribute type.</span></li><li><strong>Handling attributes being added or removed</strong><span>: currently, the attribute names are stored in the kbi.NodeViewModel when the model is initially checked. We could watch for change events and update the attributes lists accordingly</span></li><li><strong>Customized Styling</strong><span>: when I initially implemented the inspector, I used Twitter Bootstrap to provide styling and icons, but in the released version, I removed the dependency. Perhaps there should be hooks in the templates to customize more styling aspects of the inspector?</span></li><li><strong>Model and Collection Editing</strong><span>: Currently, attributes cannot be added or removed to models and models cannot be added or remove to/from collections.</span></li><li><strong>RESTful Server Actions</strong><span>: Currently, you can easily GET from a server, but there is no ability to POST or PUT. Some action buttons or functionality could be added.</span></li></ul></p><p>If you would like to implement these enhancements (or any others that would be generally useful) and contribute them back to the project, please just submit a pull request.</p></section></content><footer class="page"></footer></div></div></body></html>