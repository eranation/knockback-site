extends ../../_layout/_layout_template

include ../../_layout/_layout_mixins

block title
  title= "Tutorial: Inspector Library"

block includes
  link(rel="stylesheet",href="stylesheets/tutorial.css")
  include ../../_demos/_demos_include_knockback_scripts

block navbar
  mixin pageNavbar('Tutorials', true)

block overview
  h2#overview='Overview'

  p="Let's start with the goals of a simple model and collection inspector..."

  h4='Model Inspector Goals'
  ul
    li='For each simple-typed attribute, provide a label for the attribute name and a text box to edit the value'
    li='For each model-typed attribute, provide a collapsable node with the attribute name and when opened, allow each model attribute to be inspected by type'
    li='For each collection-typed attribute, provide a collapsable node with the attribute name and when opened, allow each model to be inspected'

  h4='Collection Inspector Goals'
  ul
    li='For each model-typed attribute, provide a collapsable node with the index model and when opened, allow each model attribute to be inspected bytype'

  h3='Inspector Visualization'
  p='Here is what the inspector could look like for a house model that has a location (simple-typed attribute) and multiple occupants (collection-typed attribute) who each has an id (simple-typed attribute), a name (simple-typed attribute), and who know which house they are living in (model-typed attribute):'
  br
  img.screen_shot(src='images/tutorial_inspector/screen_shot.png')
  br

  h2#html_architecture='HTML Architecture'

  p='Given the recursiveness of the design, I chose to implement this functionality using two reusable HTML templates: one for a model node that generates HTML for each of its attributes and one for a collection node that generates HTML for each for its models:'

  h4="Model Node View Structure (template: 'kbi_model_node')"
  p='Here is some pseudo-HTML for the model node:'
  pre.
    <li data-bind="css: {opened: opened, closed: !opened()}">
      <div data-bind="click: toggle">
        <span data-bind="text: (opened() ? '- ' : '+ ' )"></span>
        <span data-bind="text: name"></span>
      </div>

      <form>
        <!-- FOREACH ATTRIBUTE -->

          <!-- IF SIMPLE -->
            <fieldset>
              <label></label>
              <input type="text">
            </fieldset>

          <!-- ELSE IF MODEL -->
            <!-- RENDER MODEL NODE -->

          <!-- ELSE IF COLLECTION -->
            <!-- RENDER COLLECTION NODE -->

      </form>
    </li>
  strong='Highlights:'
  ul
    li='each model node uses a <li> that can either be in opened or closed state'
    li='use a <div> to wrap a +/- state indicator, the name of the node, and a click handler to toggle the opened/closed state of the node'
    li='the model attributes are grouped in a <form>'
    li='each simple-typed attribute are wrapped in a <fieldset> in with a <label> and <input> for the name and value, respectively'
    li='each model-typed attribute are rendered using the model node template'
    li='each collection-typed attribute are rendered using the collection node template'

  h4="Collection Node View Structure (template: 'kbi_collection_node')"
  p='Here is some pseudo-HTML for the collection node:'
  pre.
    <li data-bind="css: {opened: opened, closed: !opened()}">
      <div data-bind="click: toggle">
        <span data-bind="text: (opened() ? '- ' : '+ ' )"></span>
        <span data-bind="text: name"></span>
      </div>

      <!-- FOREACH MODEL -->
        <!-- RENDER MODEL NODE -->
    </li>

  strong='Highlights:'
  ul
    li='each collection node uses a <li> that can either be in opened or closed state'
    li='use a <div> to wrap a +/- state indicator, the name of the node, and a click handler to toggle the opened/closed state of the node'
    li="the collection's models are wrapped in an <ul> and each model can be rendered using the model node template"

  h2#control_flow_architecture='Control Flow Architecture'

  p
    span='We can implement an inspector by:'
    ol
      li='Using Knockback to generate a graph starting at a kb.ViewModel or kb.CollectionObservable from a Backbone.Model or Backbone.Collection, respectively.'
      li='Using Knockout to traverse the graph, to wrap each kb.ViewModel node or kb.CollectionObservable node in a NodeViewModel, and to conditionally continue to render the graph depending on the opened/closed state of the node.'

  h3='Graph Generation'
  P
    span='By default, a kb.ViewModel will generate a kb.ViewModel for each of its nested models and a kb.collectionObservable for each of its nested collections when used like:'
    pre.
      kb.viewModel(my_model)
    span='Also, a kb.CollectionObservable can easily be configured to generate a kb.ViewModel for each of its models like:'
    pre.
      kb.collectionObservable(my_collection, {view_model: kb.ViewModel})
    span="What this means is that Knockback takes care of circular references between Backbone.Models or Backbone.Collections so you don't have to. In the case of circular references, you just need to be careful to handle cycles correctly when you traverse the nodes in the graph."

  h3='Traversing the Graph'
  p='Because there can be cycles between the models and collections in the graph, the inspector uses a separate kbi.NodeViewModel to expose properties for the opened/closed state of the node, the name of the node, and the (potentially shared) node itself. A kbi.NodeViewModel is constructed with the following parameters: (name, opened_state, kb.ViewModel or kb.CollectionObservable).'
  p='By doing this, the same kb.ViewModel for a model can be opened or closed in different parts of the tree and can have unique names depending on where it is referenced from.'
  p="Also, each of the node templates, needs to take appropriate action to block the full tree from being rendered out when a kbi.NodeViewModel is in the closed state. With Knockout, this is easy to do using a '<!-- ko if: opened -->' control flow statement."

  p="Updating the 'kbi_model_node' pseudo HTML: "
  pre.
    <li data-bind="css: {opened: opened, closed: !opened()}">
      <div data-bind="click: toggle">
        <span data-bind="text: (opened() ? '- ' : '+ ' )"></span>
        <span data-bind="text: name"></span>
      </div>

      <!-- ko if: opened -->
        <form>
          <!-- FOREACH ATTRIBUTE -->

            <!-- IF SIMPLE -->
              <fieldset>
                <label></label>
                <input type="text">
              </fieldset>

            <!-- ELSE IF MODEL -->
              <ul data-bind="template: {name: 'kbi_model_node', data: new kbi.NodeViewModel(attribute_name, false, node)}"></ul>

            <!-- ELSE IF COLLECTION -->
              <ul data-bind="template: {name: 'kbi_collection_node', data: new kbi.NodeViewModel(attribute_name+'[]', true, node)}"></ul>

        </form>
      <!-- /ko -->
    </li>

  p="Updating the 'kbi_collection_node' pseudo HTML: "
  pre.
    <li data-bind="css: {opened: opened, closed: !opened()}">
      <div data-bind="click: toggle">
        <span data-bind="text: (opened() ? '- ' : '+ ' )"></span>
        <span data-bind="text: name"></span>
      </div>

      <!-- ko if: opened -->
        <!-- FOREACH MODEL -->
          <ul data-bind="template: {name: 'kbi_model_node', data: new kbi.NodeViewModel('['+$index()+']', false, node)}"></ul>
      <!-- /ko -->
    </li>

  p
    strong='Please note:'
    ul
      li="Each kb.ViewModel or kb.CollectionObservable node is rendered with <ul> to start a new tree that is filled in by either the 'kbi_model_node' or 'kbi_collection_node' templates."
      li="Each kbi.NodeViewModel is given a name to indicate its relationship."
      li="In the case of models, the templates are rendered in a closed state to break potential cycles; whereas, collections are rendered in an open state so we are presented with the indices of the contained models."
      li="When the node is closed, only the HTML that displays the name of the node and allows for a click to open the node is generated."

  h2#library_architecture='Knockback Inspector Library Architecture and Implementation Details'
  p
    ol
      li="We will create a namespace 'kbi' for the Knockback inspector"

      li
        span='We will traverse the root provided to create a '
        a(href='docs_kb_view_model.html')='kb.ViewModel'
        span=' with Knockback observables for Backbone.Model attributes or to create a '
        a(href='docs_kb_collection_observable.html')='kb.CollectionObservable'
        span=' to generate kb.ViewModels for each model in a Backbone.Collection.'
      li
        span='We will create a ViewModel node and corresponding View for each kb.ViewModel that wraps a Backbone.Model so they can be named, opened, etc...'
        span='The ViewModel for each node should have the following properties:'
        ul
          li
            strong='kb.ViewModel'
            span=' : the view model that was automatically generated by Knockback. Basically, each node will refer to a kb.ViewModel rather than being shared so it can have its own opened/closed state, name, etc'
          li
            strong='Attribute Names'
            span=' : in order to be able to iterate through all of the attributes in a Backbone.Model with Knockout, we will store their names in an array.'
          li
            strong='Name'
            span=' : a name indicating that it is the starting/root node, giving the name of the owning attribute if it is stored in a Backbone.Model attribute, or giving the index if it is stored in a Backbone.Collection'
          li
            strong='Expanded'
            span=' : a boolean indicating whether the node is open or closed. Non-root nodes will start closed to avoid infinite recursion in Backbone.Model relationship cycles.'
        span='The View for each node should be structured as follows:'
        ul
          li='There should be a way to indicate that the node is opened or closed along with the node name.'
          li="Only if the node is opened, we will traverse the Backbone.Model's attributes to avoid infinite recursion for nested models."
          li="When opened, we will render each attribute depending on its type:"
            ul
              li
                strong='Backbone.Model'
                span=' : recursively render a View Model node for the nested model'
              li
                strong='Backbone.Collection'
                span=' : render a kb.CollectionObservable node for the nested collection'
              li
                strong='Simple Attribute'
                span=' : render a the name of the attribute and an input to change the value'
      li
        span='We will create a ViewModel node and corresponding View for each kb.CollectionObservable that wraps a Backbone.Collection so they can be named, opened, etc...'
        span='The ViewModel for each node should have the following properties:'
        ul
          li
            strong='kb.CollectionObservable'
            span=' : the collection observable that was automatically generated by Knockback. Basically, each node will refer to a kb.CollectionObservable rather than being shared so it can have its own opened/closed state, name, etc'
          li
            strong='Name'
            span=' : a name indicating that it is the starting/root node, or giving the name of the owning attribute if it is stored in a Backbone.Model attribute'
          li
            strong='Expanded'
            span=' : a boolean indicating whether the node is open or closed. Non-root nodes will start closed to avoid infinite recursion in Backbone.Model relationship cycles.'
        span='The View for each node should be structured as follows:'
        ul
          li='There should be a way to indicate that the node is opened or closed along with the node name.'
          li="Only if the node is opened, we will traverse the Backbone.Collection's models to avoid infinite recursion for nested models."
          li="When opened, we will render each model using the ViewModel node (as above)"
    p="OK. Let's start..."

    h3='Implementing the Design'
    p
      span='What we are going to do is first start with a version embedded in index.html (Step 1) and then package a library (Step 2) that can be used in a jsFiddle or even your own website for debugging!'

block step1
  h2='Step 1: Setting up the Project'

  p="This tutorial demonstrates how to use Knockback to create a tree view to inspect Backbone.Model attributes and Backbone.Collections including potentially recursive relationships between models."
  p="The application is built using CoffeeScript and JavaScript."

  h3='Shared'
  ol
    li
      span="Create a new project with the following structure: "
      pre.
        - knockback-inspector
          - vendor
            - javascripts
    li
      span="Put all of the dependent libraries into the 'vendor/javascripts' folder"
      ul
        li
          a(href='http://jquery.com/')='jQuery.js'
        li
          a(href='https://github.com/SteveSanderson/knockout/downloads/')='Knockout.js'
        li
          a(href='http://documentcloud.github.com/underscore/')='Underscore.js'
        li
          a(href='http://documentcloud.github.com/backbone/')='Backbone.js'
        li
          a(href='http://kmalakoff.github.com/knockback/')='Knockback.js'
        li
          a(href='https://github.com/PaulUithol/Backbone-relational/')='Backbone-Relational (optional, but recommended)'

    li
      span="Create an index.html file in the root project directory referring to all the dependencies like (updating version and production/development version naming to match your files):"
      pre.
        - knockback-inspector
          - index.html
          - vendor
            - javascripts
      pre.
        <!doctype html>
        <head>
          <meta charset="utf-8">
          <meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1">
          <title>Knockback Inspector</title>
          <script src="vendor/javascripts/jquery-1.7.2.js"></script>
          <script src="vendor/javascripts/knockout-2.1.0.js"></script>
          <script src="vendor/javascripts/underscore-1.3.1.js"></script>
          <script src="vendor/javascripts/backbone-0.9.2.js"></script>
          <script src="vendor/javascripts/backbone-relational.js"></script>
          <script src="vendor/javascripts/knockback-0.15.1.js"></script>
        </head>
        <body>
          <h1>Knockback Inspector</h1>
        </body>
        </html>
    li
      span="Now open your index.html. You should see 'Knockback Inspector' in the page and there should be no missing file errors in your browser's debugger."
  h3='JavaScript'
  ol
    li
      span="Create a new project with the following structure: "
      pre.
        - knockback-inspector
          - index.html
          - javascripts
          - vendor
            - javascripts
  h3='Building a Scaffold Project (CoffeeScript)'
  ol
    li
      span="Create a new project with the following structure: "
      pre.
        - knockback-inspector
          - index.html
          - coffeescripts
          - vendor
            - javascripts
    li
      span="Install "
      a(href='http://nodejs.org/')='Node.js'
    li
      span="Install "
      a(href='http://coffeescript.org/')='CoffeeScript'
      pre.
        (sudo) npm install -g coffee-script

    li
      span="If you are using CoffeeScript, you need to set up an executable Cakefile build file with 'build' and 'watch' commands like:"
      pre.
        {print} = require 'util'
        {spawn} = require 'child_process'

        task 'build', 'Build javascripts/ from coffeescripts/', ->
          coffee = spawn 'coffee', ['-c', '-o', 'javascripts', 'coffeescripts']
          coffee.stderr.on 'data', (data) ->
            process.stderr.write data.toString()
          coffee.stdout.on 'data', (data) ->
            print data.toString()
          coffee.on 'exit', (code) ->
            callback?() if code is 0

        task 'watch', 'Watch coffeescripts/ for changes', ->
          coffee = spawn 'coffee', ['-w', '-c', '-o', 'javascripts', 'coffeescripts']
          coffee.stderr.on 'data', (data) ->
            process.stderr.write data.toString()
          coffee.stdout.on 'data', (data) ->
            print data.toString()

block step2
  h2='Step 2: Create a Hard-Coded Version Embedded in index.html'
  p
    span="First, we will hard-code a model and collection relationship in index.html. We will use straight JavaScript in this step since it will be included in the .html file body as:"
    pre.
      <script type='text/javascript'>
        var collection = new Backbone.Collection([]);
        var model1 = new Backbone.Model({name: 'Model1', friends: collection});
        var model2 = new Backbone.Model({name: 'Model2', friend: model1});
        collection.add(model2);
      </script>
  p
    span="TODO:"
    pre(data-for='cs').
      @kbi or= {}
      @kbi.VERSION = '0.1.0'
    pre(data-for='js').
      TODO

    span="Next, we will create the ViewModel nodes for the kb.ViewModel and kb.CollectionObservable. To keep things simple, we'll create a single ViewModel class for both collections and models starting with 'view_models/kbi_node_view_model.coffee' or 'view_models/kbi_node_view_model.js':"
    pre(data-for='cs').
      class kbi.NodeViewModel
        constructor: (name, opened, kb_object) ->
          @name = name
          @opened = ko.observable(opened)
          @kb_object = kb_object

        toggle: -> @opened(!@opened())
    pre(data-for='js').
      TODO

    span="Next, we will add the attribute functionality used for Backbone.Model's kb.ViewModels:"

    pre(data-for='cs').
      class kbi.NodeViewModel
        constructor: (name, opened, kb_object) ->
          @name = name
          @opened = ko.observable(opened)
          @kb_object = kb_object

          # a kb.ViewModel indicates the kb_object is a Backbone.Model
          if (@kb_object instanceof kb.ViewModel)
            model = kb.utils.wrappedModel(@kb_object)
            @attributes = ko.observableArray(if (model and model.attributes) then _.keys(model.attributes) else [])

        toggle: -> @opened(!@opened())

        attributeType: (key) ->
          attribute_connector = @kb_object[key]
          return 'model' if (ko.utils.unwrapObservable(attribute_connector) instanceof kb.ViewModel)
          return 'collection' if kb.utils.observableInstanceOf(attribute_connector, kb.CollectionAttributeConnector)
          return 'simple'
    pre(data-for='js').
      TODO

    p
      span="The new code in the constructor checks to see if the Knockback object is a kb.ViewModel meaning it wraps a Backbone.Model and if so, it stores the attribute names in a ko.observableArray for later traversing"
      pre(data-for='cs').
        # a kb.ViewModel indicates the kb_object is a Backbone.Model
        if (@kb_object instanceof kb.ViewModel)
          model = kb.utils.wrappedModel(@kb_object)
          @attributes = ko.observableArray(if (model and model.attributes) then _.keys(model.attributes) else [])
      pre(data-for='js').
        TODO

    p
      span="The new function 'attributeType(key)' is a helper to see what type each attribute is so that Views for nested models, collections, and simple attribute types can be selected more easily."
      pre(data-for='cs').
        attribute_connector = @kb_object[key]
        return 'model' if (ko.utils.unwrapObservable(attribute_connector) instanceof kb.ViewModel)
        return 'collection' if kb.utils.observableInstanceOf(attribute_connector, kb.CollectionAttributeConnector)
        return 'simple'
      pre(data-for='js').
        TODO

    span="Next, we will create the View templates for each node type. Because Knockout handles all of the dynamic aspects of the template, we can simply use a static string for our templates"

  h3='Views'
    p
      span='TODO: add styles including kbi classes'

    p
      span="Let's start with the kb.CollectionObservable View by creating the following file in 'views/kbi_collection_node_view_html.coffee' or 'views/kbi_collection_node_view_html.js'"
    pre(data-for='cs').
      kbi.CollectionNodeViewHTML = """
      <li>
        <span><i data-bind="click: toggle, css:{'icon-plus': !opened(), 'icon-minus': opened}"></i></i><i class="icon-th-list"></i> <span data-bind="text: name"></span></span>

        <!-- ko if: opened -->
          <div data-bind="foreach: collection_observable">
            <ul class='tree' data-bind="template: {name: 'views/templates/model_node', data:  collectionModelNodeViewModel($parent.collection_observable, false, $data)}"></ul>
          </div>
        <!-- /ko -->
      </li>
      """
    pre(data-for='js').
      TODO

    span="For the kb.ViewModel View we will create the following file in 'views/kbi_model_node_view_html.coffee' or 'views/kbi_model_node_view_html.js'. To start with, let's look at the high level structure:"
    pre(data-for='cs').
      kbi.ModelNodeViewHTML = """
      <li>
        <span><i data-bind="click: toggle, css:{'icon-plus': !opened(), 'icon-minus': opened}"></i></i><i class="icon-book"></i> <span data-bind="text: name"></span></span>
        <!-- ko if: opened -->
          <!-- ko foreach: attributes -->

            <!-- ko if: ($parent.attributeType($data) == 'model') -->
              ...
            <!-- /ko -->

            <!-- ko if: ($parent.attributeType($data) == 'collection') -->
              ...
            <!-- /ko -->

            <!-- ko if: ($parent.attributeType($data) == 'simple') -->
              ...
            <!-- /ko -->

          <!-- /ko -->
        <!-- /ko -->
      </li>
      """
    pre(data-for='js').
      TODO

    p
      span="The structure is similar to View for a collection node. We only render the attributes if the node is opened, and when opened, we traverse each attribute and depending on each type (model, collection, or simple), we render them. OK. Let's add the rendering per type."
    h4='Model Attributes'
    p
      span='For a model, we just rendering the same template again as follows:'
      pre.
        <ul class='kbi' data-bind="template: {name: 'kbi_model_node', data: new kbi.NodeViewModel($data, false, $parent.kb_object[$data])}"></ul>

      span="Note: because we are rendering the template inside the iteration of attributes, $data stores the attribute name and the attribute information is in the parent's kb.ViewModel so we access it using Knockout's $parent in the binding context like '$parent.kb_object[$data]'."

    h4='Collection Attributes'
    p
      span='For a collection, we render the collection node template and generate a name using the $index property that Knockout provides:'
      pre.
        <ul class='kbi' data-bind="template: {name: 'kbi_collection_node', data: new kbi.NodeViewModel($data, true, $parent.kb_object[$data])}"></ul>

      span="Note: because we are rendering the template inside the iteration of attributes, $data stores the attribute name and the attribute information is in the parent's kb.ViewModel so we access it using Knockout's $parent in the binding context like '$parent.kb_object[$data]'."

    h4='Simple Attributes'
    p
      span='For the attributes, we will just create a label and text input box.'
      pre.
        <fieldset>
          <label class='control-label' data-bind="text: $data"> </label>
          <input class='input-large' type="text" data-bind="value: $parent.kb_object[$data]">
        </fieldset>

    h4='Putting it all together'
    p
      span='If we combine everything, we get the following template.'
      pre.
        kbi.ModelNodeViewHTML = """
        <li class='kbi'>
          <div class='kbi model' data-bind="click: toggle, css: {opened: opened, closed: !opened()}"><span data-bind="text: name"></span> (M)</div>

          <!-- ko if: opened -->
            <form class='kbi'>
              <!-- ko foreach: attributes -->

                <!-- ko if: ($parent.attributeType($data) == 'model') -->
                  <ul class='kbi' data-bind="template: {name: 'kbi_model_node', data: new kbi.NodeViewModel($data, false, $parent.kb_object[$data])}"></ul>
                <!-- /ko -->

                <!-- ko if: ($parent.attributeType($data) == 'collection') -->
                  <ul class='kbi' data-bind="template: {name: 'kbi_collection_node', data: new kbi.NodeViewModel($data, true, $parent.kb_object[$data])}"></ul>
                <!-- /ko -->

                <!-- ko if: ($parent.attributeType($data) == 'simple') -->
                  <fieldset>
                    <label class='control-label' data-bind="text: $data"> </label>
                    <input class='input-large' type="text" data-bind="value: $parent.kb_object[$data]">
                  </fieldset>
                <!-- /ko -->

              <!-- /ko -->
            </form>
          <!-- /ko -->
        </li>
        """

    h3="Exposing the Templates to Knockout"
    p
      span="Knockout works out of the box on a static HTML page where all templates are inlined, but because we are providing our templates in a library as strings and because they can be recursive, we have assigned them names 'kbi_collection_node' and 'kbi_model_node' that need to be looked up somewhere to provide the HTML to Knockout for binding purposes. There are two implementations Knockout requires for this: 'templateEngine' and 'templateSource': you can look at "
      a(href='http://www.knockmeout.net/2011/10/ko-13-preview-part-3-template-sources.html')='an in-depth tutorial online for a full implementation'
      span="but for now, I'll try to keep the code and support to a minimum"

    pre(data-for='cs').
      TODO
    pre(data-for='js').
      // template source
      kbi.StringTemplateSource = function(template_string) {
        this.template_string = template_string;
        return this;
      };
      kbi.StringTemplateSource.prototype.text = function(value) { return this.template_string; };

      // template engine
      kbi.StringTemplateEngine = function() { return this; };
      kbi.StringTemplateEngine.prototype = new ko.nativeTemplateEngine();
      kbi.StringTemplateEngine.prototype.makeTemplateSource = function(template) {
        switch (template) {
          case 'kbi_model_node':
            return new kbi.StringTemplateSource(kbi.ModelNodeViewHTML);
          case 'kbi_collection_node':
            return new kbi.StringTemplateSource(kbi.CollectionNodeViewHTML);
          default:
            return ko.nativeTemplateEngine.prototype.makeTemplateSource.apply(this, arguments);
        }
      };

    p="The kbi.StringTemplateSource is a template source that uses a 'text' function to return an HTML string (but does not handle Knockout template re-writing nor data storage)."
    p="The kbi.StringTemplateEngine derives from ko.nativeTemplateEngine() and returns a kbi.StringTemplateSource is if recognizes the name or the default implementation otherwise. If you want to integrate the Knockout-Inspector templates into your own application, you'll need to supply a similar way to return the View strings."
    p="We tell Knockout about our custom 'kbi.StringTemplateEngine' template engine using the following call in index.html:"
    pre.
      <script type='text/javascript'>
        // set the template engine so Knockout can find 'kbi_model_node' and 'kbi_collection_node' templates
        ko.setTemplateEngine(new kbi.StringTemplateEngine());
      </script>
    p='Setting the template engine is done in the index.html file rather than the library so you can hook up your own template engine implementation as you need depending on which template engine you are using.'

    h3='Hooking up index.html'
    p="Next, we need to update the index file to provide all of the javascript files"
    pre.
      <script src="javascripts/view_models/kbi_node_view_model.js"></script>
      <script src="javascripts/views/kbi_collection_node_view.js"></script>
      <script src="javascripts/views/kbi_model_node_view.js"></script>
      <script src="javascripts/lib/kbi_string_template_engine.js"></script>

    h3='Providing Sample Data to Inspect'
    p=""

block step3
  h2='Step 3: Add Model Fetching'
  p='TODO'

block step4
  h2='Step 4: Create a Reusable Library Version'
  p='TODO'

block future_enhacements
  h2='Future Enhancement Ideas'
  p
    span='The inspector works for the most part, but as with anything it can always be improved! Here are some ideas: '
    ul
      li
        strong='Customized Attribute Editing'
        span=": currently, each attribute can be edited using a text box, but for some attribute types, this isn't very useful. Specific attribute editors could be rendered depending on the attribute type."
      li
        strong='Handling attributes being added or removed'
        span=': currently, the attribute names are stored in the kbi.NodeViewModel when the model is initially checked. We could watch for change events and update the attributes lists accordingly'
      li
        strong='Customized Styling'
        span=': when I initially implemented the inspector, I used Twitter Bootstrap to provide styling and icons, but in the released version, I removed the dependency. Perhaps there should be hooks in the templates to customize more styling aspects of the inspector?'
      li
        strong='Model and Collection Editing'
        span=': Currently, attributes cannot be added or removed to models and models cannot be added or remove to/from collections.'
      li
        strong='RESTful Server Actions'
        span=': Currently, you can easily GET from a server, but there is no ability to POST or PUT. Some action buttons or functionality could be added.'

  p='If you would like to implement these enhancements (or any others that would be generally useful) and contribute them back to the project, please just submit a pull request.'

block content
  section
    h1='Tutorial: Knockback Inspector Library'

    p='This tutorial shows how to create an inspector for a Backbone.Model or a Backbone.Collection that you can embed in your website for debugging purposes. For a model, the inspector allows you to view and edit its attributes including nested models and collections; for a collection, the inspector allows you to view and edit its models.'

    p
      span='Although the inspector can be useful as presented in this tutorial, this version is simple and stripped down for learning purposes; for example, it does not treat changing of model ids as a special case, there are no special editors for time/date/color attribute types, etc. For the latest full implementation:'
      ul
        li: a(href='https://github.com/kmalakoff/knockback-inspector/')='View the GitHub project'
        li: a(href='http://kmalakoff.github.com/knockback-inspector/')='Try the demo'
      span='Feel free to contribute to the GitHub project with your own ideas or with some of the proposals in the "Future Enhancements" section.'

    h2='Table of Contents'
    ol
      li: a(href='#overview')='Overview'
      li: a(href='#html_architecture')='HTML Architecture'
      li: a(href='#control_flow_architecture')='Control Flow Architecture'
      li: a(href='#library_architecture')='Library Architecture and Implementation Details'

    block overview
    block step1
    block step2
    block step3
    block step4
    block future_enhacements
