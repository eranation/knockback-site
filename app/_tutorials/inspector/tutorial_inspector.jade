extends ../../_layout/_layout_template

include ../../_layout/_layout_mixins

block title
  title= "Tutorial: Inspector"

block includes
  link(rel="stylesheet",href="stylesheets/tutorial.css")
  include ../../_demos/_demos_include_knockback_scripts

block navbar
  mixin pageNavbar('Tutorials', true)

block overview
  h2='Overview'



  h3='Screen Shot'

  img(src='images/tutorial_inspector/screen_shot.png')

  h3='Design'
  p
    span='The design is as follows:'
    ol
      li="We will create a namespace 'kbi' for the Knockback inspector"

      li
        span='We will traverse the root provided to create a '
        a(href='docs_kb_view_model.html')='kb.ViewModel'
        span=' with Knockback observables for Backbone.Model attributes or to create a '
        a(href='docs_kb_collection_observable.html')='kb.CollectionObservable'
        span=' to generate kb.ViewModels for each model in a Backbone.Collection.'
      li
        span='We will create a ViewModel node and corresponding View for each kb.ViewModel that wraps a Backbone.Model so they can be named, opened, etc...'
        span='The ViewModel for each node should have the following properties:'
        ul
          li
            strong='kb.ViewModel'
            span=' : the view model that was automatically generated by Knockback. Basically, each node will refer to a kb.ViewModel rather than being shared so it can have its own opened/closed state, name, etc'
          li
            strong='Attribute Names'
            span=' : in order to be able to iterate through all of the attributes in a Backbone.Model with Knockout, we will store their names in an array.'
          li
            strong='Name'
            span=' : a name indicating that it is the starting/root node, giving the name of the owning attribute if it is stored in a Backbone.Model attribute, or giving the index if it is stored in a Backbone.Collection'
          li
            strong='Expanded'
            span=' : a boolean indicating whether the node is open or closed. Non-root nodes will start closed to avoid infinite recursion in Backbone.Model relationship cycles.'
        span='The View for each node should be structured as follows:'
        ul
          li='There should be a way to indicate that the node is opened or closed along with the node name.'
          li="Only if the node is opened, we will traverse the Backbone.Model's attributes to avoid infinite recursion for nested models."
          li="When opened, we will render each attribute depending on its type:"
            ul
              li
                strong='Backbone.Model'
                span=' : recursively render a View Model node for the nested model'
              li
                strong='Backbone.Collection'
                span=' : render a kb.CollectionObservable node for the nested collection'
              li
                strong='Simple Attribute'
                span=' : render a the name of the attribute and an input to change the value'
      li
        span='We will create a ViewModel node and corresponding View for each kb.CollectionObservable that wraps a Backbone.Collection so they can be named, opened, etc...'
        span='The ViewModel for each node should have the following properties:'
        ul
          li
            strong='kb.CollectionObservable'
            span=' : the collection observable that was automatically generated by Knockback. Basically, each node will refer to a kb.CollectionObservable rather than being shared so it can have its own opened/closed state, name, etc'
          li
            strong='Name'
            span=' : a name indicating that it is the starting/root node, or giving the name of the owning attribute if it is stored in a Backbone.Model attribute'
          li
            strong='Expanded'
            span=' : a boolean indicating whether the node is open or closed. Non-root nodes will start closed to avoid infinite recursion in Backbone.Model relationship cycles.'
        span='The View for each node should be structured as follows:'
        ul
          li='There should be a way to indicate that the node is opened or closed along with the node name.'
          li="Only if the node is opened, we will traverse the Backbone.Collection's models to avoid infinite recursion for nested models."
          li="When opened, we will render each model using the ViewModel node (as above)"
    p="OK. Let's start..."

    h3='Implementing the Design'
    p
      span='What we are going to do is first start with a version embedded in index.html (Step 1) and then package a library (Step 2) that can be used in a jsFiddle or even your own website for debugging!'

block step1
  h2='Step 1: Setting up the Project'

  p="This tutorial demonstrates how to use Knockback to create a tree view to inspect Backbone.Model attributes and Backbone.Collections including potentially recursive relationships between models."
  p="The application is built using CoffeeScript and JavaScript."

  h3='Shared'
  ol
    li
      span="Create a new project with the following structure: "
      pre.
        - knockback-inspector
          - vendor
            - javascripts
    li
      span="Put all of the dependent libraries into the 'vendor/javascripts' folder"
      ul
        li
          a(href='http://jquery.com/')='jQuery.js'
        li
          a(href='https://github.com/SteveSanderson/knockout/downloads/')='Knockout.js'
        li
          a(href='http://documentcloud.github.com/underscore/')='Underscore.js'
        li
          a(href='http://documentcloud.github.com/backbone/')='Backbone.js'
        li
          a(href='http://kmalakoff.github.com/knockback/')='Knockback.js'
        li
          a(href='https://github.com/PaulUithol/Backbone-relational/')='Backbone-Relational (optional, but recommended)'

    li
      span="Create an index.html file in the root project directory referring to all the dependencies like (updating version and production/development version naming to match your files):"
      pre.
        - knockback-inspector
          - index.html
          - vendor
            - javascripts
      pre.
        <!doctype html>
        <head>
          <meta charset="utf-8">
          <meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1">
          <title>Knockback Inspector</title>
          <script src="vendor/javascripts/jquery-1.7.2.js"></script>
          <script src="vendor/javascripts/knockout-2.1.0.js"></script>
          <script src="vendor/javascripts/underscore-1.3.1.js"></script>
          <script src="vendor/javascripts/backbone-0.9.2.js"></script>
          <script src="vendor/javascripts/backbone-relational.js"></script>
          <script src="vendor/javascripts/knockback-0.15.1.js"></script>
        </head>
        <body>
          <h1>Knockback Inspector</h1>
        </body>
        </html>
    li
      span="Now open your index.html. You should see 'Knockback Inspector' in the page and there should be no missing file errors in your browser's debugger."
  h3='JavaScript'
  ol
    li
      span="Create a new project with the following structure: "
      pre.
        - knockback-inspector
          - index.html
          - javascripts
          - vendor
            - javascripts
  h3='Building a Scaffold Project (CoffeeScript)'
  ol
    li
      span="Create a new project with the following structure: "
      pre.
        - knockback-inspector
          - index.html
          - coffeescripts
          - vendor
            - javascripts
    li
      span="Install "
      a(href='http://nodejs.org/')='Node.js'
    li
      span="Install "
      a(href='http://coffeescript.org/')='CoffeeScript'
      pre.
        (sudo) npm install -g coffee-script

    li
      span="If you are using CoffeeScript, you need to set up an executable Cakefile build file with 'build' and 'watch' commands like:"
      pre.
        {print} = require 'util'
        {spawn} = require 'child_process'

        task 'build', 'Build javascripts/ from coffeescripts/', ->
          coffee = spawn 'coffee', ['-c', '-o', 'javascripts', 'coffeescripts']
          coffee.stderr.on 'data', (data) ->
            process.stderr.write data.toString()
          coffee.stdout.on 'data', (data) ->
            print data.toString()
          coffee.on 'exit', (code) ->
            callback?() if code is 0

        task 'watch', 'Watch coffeescripts/ for changes', ->
          coffee = spawn 'coffee', ['-w', '-c', '-o', 'javascripts', 'coffeescripts']
          coffee.stderr.on 'data', (data) ->
            process.stderr.write data.toString()
          coffee.stdout.on 'data', (data) ->
            print data.toString()

block step2
  h2='Step 2: Create a Hard-Coded Version Embedded in index.html'
  p
    span="First, we will hard-code a model and collection relationship in index.html. We will use straight JavaScript in this step since it will be included in the .html file body as:"
    pre.
      <script type='text/javascript'>
        var collection = new Backbone.Collection([]);
        var model1 = new Backbone.Model({name: 'Model1', friends: collection});
        var model2 = new Backbone.Model({name: 'Model2', friend: model1});
        collection.add(model2);
      </script>
  p
    span="TODO:"
    pre(data-for='cs').
      @kbi or= {}
      @kbi.VERSION = '0.1.0'
    pre(data-for='js').
      TODO

    span="Next, we will create the ViewModel nodes for the kb.ViewModel and kb.CollectionObservable. To keep things simple, we'll create a single ViewModel class for both collections and models starting with 'view_models/kbi_node_view_model.coffee' or 'view_models/kbi_node_view_model.js':"
    pre(data-for='cs').
      class kbi.NodeViewModel
        constructor: (name, opened, kb_object) ->
          @name = name
          @opened = ko.observable(opened)
          @kb_object = kb_object

        toggle: -> @opened(!@opened())
    pre(data-for='js').
      TODO

    span="Next, we will add the attribute functionality used for Backbone.Model's kb.ViewModels:"

    pre(data-for='cs').
      class kbi.NodeViewModel
        constructor: (name, opened, kb_object) ->
          @name = name
          @opened = ko.observable(opened)
          @kb_object = kb_object

          # a kb.ViewModel indicates the kb_object is a Backbone.Model
          if (@kb_object instanceof kb.ViewModel)
            model = kb.utils.wrappedModel(@kb_object)
            @attributes = ko.observableArray(if (model and model.attributes) then _.keys(model.attributes) else [])

        toggle: -> @opened(!@opened())

        attributeType: (key) ->
          attribute_connector = @kb_object[key]
          return 'model' if (ko.utils.unwrapObservable(attribute_connector) instanceof kb.ViewModel)
          return 'collection' if kb.utils.observableInstanceOf(attribute_connector, kb.CollectionAttributeConnector)
          return 'simple'
    pre(data-for='js').
      TODO

    p
      span="The new code in the constructor checks to see if the Knockback object is a kb.ViewModel meaning it wraps a Backbone.Model and if so, it stores the attribute names in a ko.observableArray for later traversing"
      pre(data-for='cs').
        # a kb.ViewModel indicates the kb_object is a Backbone.Model
        if (@kb_object instanceof kb.ViewModel)
          model = kb.utils.wrappedModel(@kb_object)
          @attributes = ko.observableArray(if (model and model.attributes) then _.keys(model.attributes) else [])
      pre(data-for='js').
        TODO

    p
      span="The new function 'attributeType(key)' is a helper to see what type each attribute is so that Views for nested models, collections, and simple attribute types can be selected more easily."
      pre(data-for='cs').
        attribute_connector = @kb_object[key]
        return 'model' if (ko.utils.unwrapObservable(attribute_connector) instanceof kb.ViewModel)
        return 'collection' if kb.utils.observableInstanceOf(attribute_connector, kb.CollectionAttributeConnector)
        return 'simple'
      pre(data-for='js').
        TODO

    span="Next, we will create the View templates for each node type. Because Knockout handles all of the dynamic aspects of the template, we can simply use a static string for our templates"

  h3='Views'
    p
      span='TODO: add styles including kbi classes'

    p
      span="Let's start with the kb.CollectionObservable View by creating the following file in 'views/kbi_collection_node_view_html.coffee' or 'views/kbi_collection_node_view_html.js'"
    pre(data-for='cs').
      kbi.CollectionNodeViewHTML = """
      <li>
        <span><i data-bind="click: toggle, css:{'icon-plus': !opened(), 'icon-minus': opened}"></i></i><i class="icon-th-list"></i> <span data-bind="text: name"></span></span>

        <!-- ko if: opened -->
          <div data-bind="foreach: collection_observable">
            <ul class='tree' data-bind="template: {name: 'views/templates/model_node', data:  collectionModelNodeViewModel($parent.collection_observable, false, $data)}"></ul>
          </div>
        <!-- /ko -->
      </li>
      """
    pre(data-for='js').
      TODO

    span="For the kb.ViewModel View we will create the following file in 'views/kbi_model_node_view_html.coffee' or 'views/kbi_model_node_view_html.js'. To start with, let's look at the high level structure:"
    pre(data-for='cs').
      kbi.ModelNodeViewHTML = """
      <li>
        <span><i data-bind="click: toggle, css:{'icon-plus': !opened(), 'icon-minus': opened}"></i></i><i class="icon-book"></i> <span data-bind="text: name"></span></span>
        <!-- ko if: opened -->
          <!-- ko foreach: attributes -->

            <!-- ko if: ($parent.attributeType($data) == 'model') -->
              ...
            <!-- /ko -->

            <!-- ko if: ($parent.attributeType($data) == 'collection') -->
              ...
            <!-- /ko -->

            <!-- ko if: ($parent.attributeType($data) == 'simple') -->
              ...
            <!-- /ko -->

          <!-- /ko -->
        <!-- /ko -->
      </li>
      """
    pre(data-for='js').
      TODO

    p
      span="The structure is similar to View for a collection node. We only render the attributes if the node is opened, and when opened, we traverse each attribute and depending on each type (model, collection, or simple), we render them. OK. Let's add the rendering per type."
    h4='Model Attributes'
    p
      span='For a model, we just rendering the same template again as follows:'
      pre.
        <ul class='kbi' data-bind="template: {name: 'kbi_model_node', data: new kbi.NodeViewModel($data, false, $parent.kb_object[$data])}"></ul>

      span="Note: because we are rendering the template inside the iteration of attributes, $data stores the attribute name and the attribute information is in the parent's kb.ViewModel so we access it using Knockout's $parent in the binding context like '$parent.kb_object[$data]'."

    h4='Collection Attributes'
    p
      span='For a collection, we render the collection node template and generate a name using the $index property that Knockout provides:'
      pre.
        <ul class='kbi' data-bind="template: {name: 'kbi_collection_node', data: new kbi.NodeViewModel($data, true, $parent.kb_object[$data])}"></ul>

      span="Note: because we are rendering the template inside the iteration of attributes, $data stores the attribute name and the attribute information is in the parent's kb.ViewModel so we access it using Knockout's $parent in the binding context like '$parent.kb_object[$data]'."

    h4='Simple Attributes'
    p
      span='For the attributes, we will just create a label and text input box.'
      pre.
        <fieldset>
          <label class='control-label' data-bind="text: $data"> </label>
          <input class='input-large' type="text" data-bind="value: $parent.kb_object[$data]">
        </fieldset>

    h4='Putting it all together'
    p
      span='If we combine everything, we get the following template.'
      pre.
        kbi.ModelNodeViewHTML = """
        <li class='kbi'>
          <div class='kbi model' data-bind="click: toggle, css: {opened: opened, closed: !opened()}"><span data-bind="text: name"></span> (M)</div>

          <!-- ko if: opened -->
            <form class='kbi'>
              <!-- ko foreach: attributes -->

                <!-- ko if: ($parent.attributeType($data) == 'model') -->
                  <ul class='kbi' data-bind="template: {name: 'kbi_model_node', data: new kbi.NodeViewModel($data, false, $parent.kb_object[$data])}"></ul>
                <!-- /ko -->

                <!-- ko if: ($parent.attributeType($data) == 'collection') -->
                  <ul class='kbi' data-bind="template: {name: 'kbi_collection_node', data: new kbi.NodeViewModel($data, true, $parent.kb_object[$data])}"></ul>
                <!-- /ko -->

                <!-- ko if: ($parent.attributeType($data) == 'simple') -->
                  <fieldset>
                    <label class='control-label' data-bind="text: $data"> </label>
                    <input class='input-large' type="text" data-bind="value: $parent.kb_object[$data]">
                  </fieldset>
                <!-- /ko -->

              <!-- /ko -->
            </form>
          <!-- /ko -->
        </li>
        """

    h3="Exposing the Templates to Knockout"
    p
      span="Knockout works out of the box on a static HTML page where all templates are inlined, but because we are providing our templates in a library as strings and because they can be recursive, we have assigned them names 'kbi_collection_node' and 'kbi_model_node' that need to be looked up somewhere to provide the HTML to Knockout for binding purposes. There are two implementations Knockout requires for this: 'templateEngine' and 'templateSource': you can look at "
      a(href='http://www.knockmeout.net/2011/10/ko-13-preview-part-3-template-sources.html')='an in-depth tutorial online for a full implementation'
      span="but for now, I'll try to keep the code and support to a minimum"

    pre(data-for='cs').
      TODO
    pre(data-for='js').
      // template source
      kbi.StringTemplateSource = function(template_string) {
        this.template_string = template_string;
        return this;
      };
      kbi.StringTemplateSource.prototype.text = function(value) { return this.template_string; };

      // template engine
      kbi.StringTemplateEngine = function() { return this; };
      kbi.StringTemplateEngine.prototype = new ko.nativeTemplateEngine();
      kbi.StringTemplateEngine.prototype.makeTemplateSource = function(template) {
        switch (template) {
          case 'kbi_model_node':
            return new kbi.StringTemplateSource(kbi.ModelNodeViewHTML);
          case 'kbi_collection_node':
            return new kbi.StringTemplateSource(kbi.CollectionNodeViewHTML);
          default:
            return ko.nativeTemplateEngine.prototype.makeTemplateSource.apply(this, arguments);
        }
      };

    p="The kbi.StringTemplateSource is a template source that uses a 'text' function to return an HTML string (but does not handle Knockout template re-writing nor data storage)."
    p="The kbi.StringTemplateEngine derives from ko.nativeTemplateEngine() and returns a kbi.StringTemplateSource is if recognizes the name or the default implementation otherwise. If you want to integrate the Knockout-Inspector templates into your own application, you'll need to supply a similar way to return the View strings."
    p="We tell Knockout about our custom 'kbi.StringTemplateEngine' template engine using the following call in index.html:"
    pre.
      <script type='text/javascript'>
        // set the template engine so Knockout can find 'kbi_model_node' and 'kbi_collection_node' templates
        ko.setTemplateEngine(new kbi.StringTemplateEngine());
      </script>
    p='Setting the template engine is done in the index.html file rather than the library so you can hook up your own template engine implementation as you need depending on which template engine you are using.'

    h3='Hooking up index.html'
    p="Next, we need to update the index file to provide all of the javascript files"
    pre.
      <script src="javascripts/view_models/kbi_node_view_model.js"></script>
      <script src="javascripts/views/kbi_collection_node_view.js"></script>
      <script src="javascripts/views/kbi_model_node_view.js"></script>
      <script src="javascripts/lib/kbi_string_template_engine.js"></script>

    h3='Providing Sample Data to Inspect'
    p=""

block step3
  h2='Step 3: Add Model Fetching'
  p='TODO'

block step4
  h2='Step 4: Create a Reusable Library Version'
  p='TODO'

block future_enhacements
  h2='Future Enhancement Ideas'
  p
    span='The inspector works for the most part, but as with anything it can always be improved! Here are some ideas: '
    ul
      li
        strong='Customized Attribute Editing'
        span=": currently, each attribute can be edited using a text box, but for some attribute types, this isn't very useful. Specific attribute editors could be rendered depending on the attribute type."
      li
        strong='Handling attributes being added or removed'
        span=': currently, the attribute names are stored in the kbi.NodeViewModel when the model is initially checked. We could watch for change events and update the attributes lists accordingly'
      li
        strong='Customized Styling'
        span=': when I initially implemented the inspector, I used Twitter Bootstrap to provide styling and icons, but in the released version, I removed the dependency. Perhaps there should be hooks in the templates to customize more styling aspects of the inspector?'
      li
        strong='Model and Collection Editing'
        span=': Currently, attributes cannot be added or removed to models and models cannot be added or remove to/from collections.'
      li
        strong='RESTful Server Actions'
        span=': Currently, you can easily GET from a server, but there is no ability to POST or PUT. Some action buttons or functionality could be added.'

  p='If you would like to implement these enhancements (or any others that would be generally useful) and contribute them back to the project, please just submit a pull request.'

block content
  section
    h1='Tutorial: Knockback Inspector'

    p='This tutorial shows how to create an inspector for a Backbone.Model or a Backbone.Collection that you can embed in your website for debugging purposes. The inspector allows you to view and edit model attributes including nested models and collections.'

    p
      span='Although the inspector can be useful as presented in this tutorial, this version is simple and stripped down for learning purposes. For the latest full implementation:'
      ul
        li: a(href='https://github.com/kmalakoff/knockback-inspector/')='View the GitHub project'
        li: a(href='http://kmalakoff.github.com/knockback-inspector/')='Try the demo'
      span='Feel free to contribute your own ideas to the GitHub project or to implement some of the extensions in the "Future Enhancements".'

    block overview
    block step1
    block step2
    block step3
    block step4
    block future_enhacements
